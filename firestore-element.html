<link rel="import" href="firebase-firestore-script.html">
<script>
  if (typeof Polymer === 'undefined') {
    throw new Error(
      'Polymer.FirestoreElement must be imported after Polymer itself.',
    );
  }

  // Create a new scope
  {
    // Created to avoid collisions
    const LISTENERS = Symbol('polymerfire-firestore-mixin-listeners');
    const CONFIGURATIONS = Symbol('polymerfire-firestore-mixin-configurations');
    const OBSERVER_NAME = '__polymerfire_firestore_mixin_observer__';

    // Db is assigned a value of firebase.firestore() when first instance
    // of an element which uses Polymer.FirestoreElement is created.
    let db;

    class Path {
      /**
       * @typedef {Array.<string>} Parts
       */
      /**
       * Splits the path to an array of literal parts and property names used
       * as bindings.
       * Elements with even indexes are property names.
       * Elements with odd indexes are literal parts.
       * @param {string} path Path to be split.
       * @return {Parts}
       */
      static parse(path) {
        const PROPERTY_BINDING_REGEXP = /{([^{}]+)}/g;
        return path.split(PROPERTY_BINDING_REGEXP);
      }
      /**
       * @typedef {Object} SplittedParts
       * @property {Array.<string>} literals Literal parts.
       * @property {Array.<string>} propertyNames Property names.
       */
      /**
       * Splits parts into arrays of literals and property names.
       * @param {Parts} parts Parts to be split.
       * @return {SplittedParts}
       */
      static split(parts) {
        const isOdd = (x) => x & 1 === 1;
        let literals = [], propertyNames = [];
        parts.forEach((part, index) => {
          (isOdd(index) ? literals : propertyNames).push(part);
        })
        return {literals, propertyNames};
      }
      constructor(path) {
        this.parts = this.constructor.parse(path);
        Object.assign(this, this.constructor.split(this.parts));
      }
      /**
       * Computes full path replacing property names with given values.
       * @param {Array.<string>} values Values of properties on corresponding
       * indexes.
       * @return {string}
       */
      compute(values) {
        // Segment consists of property value and a literal right next to it.
        const addSegment = (path, value, index) =>
          path.concat(value, this.literals[index + 1]);
        return values.reduce(addSegment, this.literals[0] || '');
      }
    }

    class Config {
      constructor(definition) {
        this.live = definition.live;
        this.observes = definition.observes;
        this.path = new Path(definition.path);
      }
    }

    class Listener {
      static updateProperty(name, ...values) {
        this._firestoreUnlisten(name);

        const config = this._firestoreProps[name];
        const numberOfBindedProps = Math.floor(config.props.length / 2)
        const propsValues = values.slice(0, );
        const observesArgs = Array.prototype.slice.call(arguments, config.props.length + 2).filter(arg => arg);

        if (propArgs.length < config.props.length || observesArgs.length < config.observes.length) {
          this[name] = null;
          this[name + 'Ref'] = null;
          this[name + 'Ready'] = false;
          return;
        }

        const collPath = stitch(config.parts, propArgs);
        const assigner = snap => {
          this[name] = TRANSFORMS[type](snap);
          this[name + 'Ready'] = true;
        }

        let ref = this.db[type](collPath);
        this[name + 'Ref'] = ref;
        this[name + 'Ready'] = false;

        const query = this.constructor.properties[name].query;
        if (query) {
          ref = query.call(this, ref, this);
        }

        if (config.live) {
          this._firestoreListeners[name] = ref.onSnapshot(assigner);
        } else {
          ref.get().then(assigner);
        }
      }
      constructor(instance, config) {
        this.instance = instance;
        this.config = config;
        this.bind();
      }
      /**
       * Initialize listener.
       * @param {string} type
       * @param {string} path
       * @param {string} name
       * @param {boolean=false} live
       * @param {Array.<string>} observes
       */
      init() {
        const config = this.config;

        // Create a method observer that will be called every time a
        // templatized or observed property changes
        const props = config.parts.filter((_, i) => i % 2)
        let args = props.concat(config.observes).join(',');
        if (args.length) { args = ',' + args; }
        this._createMethodObserver(`_firestoreUpdateBinding('${type}','${name}'${args})`);

        if (!props.length && !config.observes.length) {
          this._firestoreUpdateBinding(type, name);
        }
      }
      createMethodObserver() {

      }
      ensureObserverAttached() {
        if (!this.instance[OBSERVER_NAME]) {
          this.instance[OBSERVER_NAME] =
            this.constructor.updateProperty.bind(this.instance);
        }
      }
      

      _firestoreUnlisten(name) {
        if (this._firestoreListeners[name]) {
          this._firestoreListeners[name]();
          delete this._firestoreListeners[name];
        }
      }
    }

    class Synced {
      
    }

    const TRANSFORMS = {
      doc: function (snap) { return iDoc(snap); },
      collection: function (snap) { return snap.empty ? [] : snap.docs.map(doc => iDoc(doc)) }
    }

    const collect = (what, which) => {
      let res = {};
      while (what) {
        res = Object.assign({}, what[which], res); // Respect prototype priority
        what = Object.getPrototypeOf(what);
      }
      return res;
    };

    const iDoc = (snap) => {
      if (snap.exists) {
        return Object.assign({ __id__: snap.id }, snap.data());
      } else {
        return null;
      }
    }

    /**
     * This mixin provides bindings to documents and collections in a
     * Cloud Firestore database through special property declarations.
     *
     * ### Basic Usage
     *
     * ```js
     * class MyElement extends Polymer.FirestoreElement(Polymer.Element) {
     *   // ...
     *   static get properties() {
     *     return {
     *       uid: String,
     *       user: {
     *         type: Object,
     *         doc: 'users/{uid}'
     *       },
     *       messages: {
     *         type: Array,
     *         collection: 'users/{uid}/messages'
     *       }
     *     }
     *   }
     * }
     * ```
     *
     * As you can see, specific properties have been decorated with `doc` and
     * `collection` options. These options provide full paths to documents or
     * collections in your Firestore database. When templatized with curly
     * braces (e.g. `{uid}` above), the data will be dynamically rebound as
     * the templatized properties change.
     *
     * PolymerFirestore bindings are **intentionally read-only**. Automatic
     * three-way binding (i.e. syncing changes from the element back up to
     * the database) are great for toy apps but largely an antipattern.
     *
     * In addition to loading data into the specified property, PolymerFirestore
     * also makes additional convenience properties:
     *
     * * `<propname>Ref`: a Firestore reference to the doc/collection
     * * `<propname>Ready`: will be true when all path segments are present and data has been fetched at least once
     *
     * ### Querying
     *
     * PolymerFire supports querying by supplying a builder function to the
     * `query` option. The function will be bound to the element and called with
     * the ref and element instance. For example:
     *
     * ```js
     * {
     *   uid: String,
     *   label: String,
     *   category: String,
     *   notes: {
     *     type: Array,
     *     collection: 'users/{uid}/notes',
     *     query: (q, el) => {
     *       q = q.orderBy('date', 'desc').limit(100)
     *       if (el.color) { q.where('color','==', el.color) }
     *       if (el.category) { q.where('category', '==', el.category) }
     *       return q;
     *     },
     *     observes: ['color', 'category']
     *   }
     * }
     * ```
     *
     * In the  above example, a rich query is further filtered down by other
     * properties on the element. Remember to declare each query-affecting
     * property in your `observes` option.
     *
     * ### Options
     *
     * * **doc:** *string*, the full (optionally templatized) path to a document
     * * **collection:** *string*, the full (optionally templatized) path to a collection
     * * **live:** *boolean*, whether or not to continue updating the property as data changes in the database
     * * **query:** *(ref: Reference, el: Element)* a query builder function that takes the computed ref and the element instance
     * * **observes:** a list of properties which, if changed, should trigger a rebuild of the query
     *
     * @polymer
     * @mixinFunction Polymer.FirestoreElement
     */
    Polymer.FirestoreElement = parent => class Mixin extends parent {
      constructor() {
        super();
        if (db === undefined) {
          db = firebase.firestore();
        }
        if (this[CONFIGURATIONS] !== undefined) {
          throw new Error(
            'Polymer.FirestoreElement must not be mixed-in twice.',
          )
        }
        this[CONFIGURATIONS] = {};
        this[LISTENERS] = {};
      }

      connectedCallback() {
        const properties = collect(this.constructor, 'properties');
        for (let name in properties) {
          if (properties.hasOwnProperty(name)) {
            const definition = properties[name]
            if (definition.doc || definition.collection) {
              const config = new Config(definition);
              this[LISTENERS][name] = new Listener(this, config);
            }
          }
        }
        super.connectedCallback();
      }
    }
  }

</script>